import json
import pandas as pd
import matplotlib.pyplot as plt
import os
import argparse



#### python plot_results.py results.json ####

def load_results(file_path: str) -> dict:
    """Loads the results from a JSON file."""
    if not os.path.exists(file_path):
        print(f"Error: Results file not found at {file_path}")
        return None
    with open(file_path, 'r') as f:
        return json.load(f)

def prepare_data(results: dict) -> pd.DataFrame:
    """
    Transforms the nested results dictionary into a flat pandas DataFrame
    suitable for plotting.
    """
    data_list = []
    for file_path, file_data in results.items():
        for solver_key, metrics in file_data.items():
            if not metrics:
                continue

            # Extract solver name (e.g., 'Greedy', 'Savings') and method ('Uncoarsened', 'Inflated')
            parts = solver_key.split()
            method = parts[0]
            solver = parts[1]
            
            # The metrics dictionary contains our data points
            for metric_name, value in metrics.items():
                # We're interested in numeric values for plotting
                if isinstance(value, (int, float)):
                    data_list.append({
                        'File': os.path.basename(file_path),
                        'Solver': solver,
                        'Method': method,
                        'Metric': metric_name,
                        'Value': value
                    })

    return pd.DataFrame(data_list)

def create_box_plots(df: pd.DataFrame, output_dir: str):
    """
    Generates and saves box plots for key metrics, comparing uncoarsened
    and inflated solutions.
    """
    if df.empty:
        print("No data available for plotting.")
        return

    # Create the output directory if it doesn't exist
    os.makedirs(output_dir, exist_ok=True)
    
    # Key metrics to visualize
    metrics_to_plot = [
        "total_distance",
        "total_route_duration",
        "num_vehicles",
        "time_window_violations",
        "capacity_violations"
    ]

    for metric in metrics_to_plot:
        # Filter for the current metric
        metric_df = df[df['Metric'] == metric]

        if metric_df.empty:
            print(f"No data for metric: {metric}. Skipping plot.")
            continue

        plt.figure(figsize=(10, 6))
        
        # Create a list of solvers present in the data for this metric
        solvers = metric_df['Solver'].unique()
        
        # Prepare the data for plotting
        plot_data = []
        labels = []
        for solver in sorted(solvers):
            for method in ['Uncoarsened', 'Inflated']:
                subset = metric_df[(metric_df['Solver'] == solver) & (metric_df['Method'] == method)]
                if not subset.empty:
                    plot_data.append(subset['Value'].values)
                    labels.append(f"{solver} ({method})")

        if not plot_data:
            print(f"Skipping plot for {metric} as no data was found.")
            continue

        # Create the box plot
        plt.boxplot(plot_data, labels=labels, patch_artist=True)
        
        plt.title(f'Comparison of {metric.replace("_", " ").title()}')
        plt.ylabel(metric.replace("_", " ").title())
        plt.xticks(rotation=45, ha='right')
        plt.grid(axis='y', linestyle='--', alpha=0.7)
        plt.tight_layout()
        
        file_name = f'boxplot_{metric}.png'
        plt.savefig(os.path.join(output_dir, file_name))
        print(f"Saved plot: {os.path.join(output_dir, file_name)}")
        plt.close()

def main():
    parser = argparse.ArgumentParser(description="Generate box plots from CVRPTW solver results.")
    parser.add_argument("input_file", type=str, help="Path to the JSON results file generated by main.py.")
    parser.add_argument("--output_dir", type=str, default="plots",
                        help="Directory to save the generated box plot images.")
    args = parser.parse_args()

    results = load_results(args.input_file)
    if results:
        df = prepare_data(results)
        create_box_plots(df, args.output_dir)

if __name__ == "__main__":
    main()
